# 原生學術代理人編輯系統：基於 Apple Intelligence 與 Typst/Rust 的完整架構藍圖

## 1. 系統架構總覽 (System Overview)

本系統採用 **分層模組化架構 (Layered Modular Architecture)**，透過 UniFFI 作為 Swift (UI/AI 層) 與 Rust (核心邏輯層) 之間的橋樑。

### 1.1 頂層設計圖

```mermaid
graph TD
    User[使用者] --> UI_Layer
    UI_Layer --> Agent_Orchestrator
    
    subgraph "Apple Intelligence (On-Device)"
        Agent_Orchestrator <--> Foundation_Models[Foundation Models Framework]
        Foundation_Models --> Writing_Tools
    end
    
    Agent_Orchestrator --> Bridge
    
    subgraph "Rust Core (Logic & Rendering)"
        Bridge --> Typst_Engine
        Bridge --> Bib_Manager[Hayagriva 書目管理]
        Bridge --> Docx_Exporter
        Typst_Engine --> Virtual_FS[虛擬檔案系統 (In-Memory)]
    end
    
    Bib_Manager <--> Zotero_Bridge
```

## 2. 核心模組詳解

### 2.1 Swift 層：代理人調度與使用者介面

這一層負責處理「不確定性」的任務，如理解使用者意圖、生成自然語言回應，以及管理 UI 狀態。

#### A. 代理人調度中心 (Agent Orchestrator)

這是 App 的「中樞神經」，實作為一個 Global Actor，負責管理多個專職 Agent。

* **技術實作**：使用 Swift 的 `DistributedActor` 或 Actor 模型來隔離狀態，避免並發衝突 [1]。
* **路由機制 (Router)**：利用 Foundation Model 的 System Prompt 進行「意圖識別」，將任務分發給專職 Agent。例如，當模型偵測到「需要引用文獻」時，呼叫 `CitationAgent`；偵測到「排版亂了」時，呼叫 `LayoutAgent` [3]。

#### B. 專職 Agent 定義

利用 Apple Foundation Models 的 `Tool` 協議定義各類 Agent 的能力 [5]。

**Editor Agent (寫作助理)：**

* **職責**：潤飾文字、轉換學術語氣 (Academic Tone)、降重 (Paraphrasing)。
* **Prompt 優化**：針對繁體中文學術用語進行 Few-shot Prompting (例如：「將『信息』轉換為『資訊』，『魯棒性』轉換為『強健性』」) [7]。
* **整合**：直接綁定 `UIWritingToolsCoordinator` 以支援系統級寫作工具 [8]。

**Citation Agent (引用助理)：**

* **職責**：搜尋書目、插入引用、格式化參考文獻。
* **工具定義**：

    ```swift
    struct SearchBibliographyTool: Tool {
        let name = "search_bib"
        @Generable struct Args { let query: String }
        func call(arguments: Args) async throws -> String {
            // 透過 UniFFI 呼叫 Rust 的 Hayagriva 搜尋功能
            return await RustCore.searchLibrary(query: arguments.query)
        }
    }
    ```

* **Zotero 整合**：透過 App Intents 或本地網路請求 (Localhost HTTP) 與 Zotero 的 Better BibTeX 插件通訊 [9]。

**Layout Agent (排版助理)：**

* **職責**：將自然語言指令 (「把標題改成大一點」) 轉換為 Typst 代碼 (`#show heading: set text(size: 14pt)`)。
* **訓練/微調**：由於通用 LLM 對 Typst 語法不熟悉，建議利用 typst-examples 數據集對模型進行 LoRA 微調 (需申請 Apple 的 Adapter Entitlement) [10]。

### 2.2 Rust 層：高效能執行引擎 (The Engine)

這一層負責處理「確定性」的任務，確保排版結果的絕對精確與高效。

#### A. Typst 編譯器封裝 (Typst Wrapper)

Typst 本身是為 CLI 設計的，我們需要將其封裝為庫 (Library) 以供 iOS 調用 [12]。

* **虛擬世界 (Custom World)**：iOS App 無法隨意存取檔案系統。我們必須實作 Typst 的 `World` trait，將檔案讀取請求重定向到 App 的 Bundle 或 Documents 目錄，甚至是在記憶體中的虛擬檔案 [14]。
* **字體嵌入**：利用 `typst-assets` 或手動嵌入開源中文字體 (如 Noto Serif TC) 到二進位檔中，確保在沒有安裝字體的 iPad 上也能正確渲染繁體中文 [16]。

#### B. 書目管理 (Hayagriva Integration)

使用 Hayagriva 庫處理 CSL (Citation Style Language) 渲染。這解決了 Swift 生態缺乏高質量 CSL 處理器的問題 [17]。

* **流程**：
    1. Swift 層傳入 JSON 格式的引用資料與 CSL 樣式 ID (如 `apa-7th-edition`)。
    2. Rust 層使用 Hayagriva 生成格式化後的 HTML 或純文字。
    3. 透過 UniFFI 回傳給 Swift 顯示。

#### C. DOCX 匯出模組

這是最棘手的部分。由於 `docx-rs` 功能有限，我們採用 **混合策略**：

* **主要路徑**：Typst -> PDF (學術投稿標準格式)。
* **編輯路徑**：Typst -> Pandoc AST -> DOCX [19]。
* **Rust 實作**：將 pandoc 的核心邏輯 (Haskell) 透過 WebAssembly (WASM) 整合，或者使用 Rust 的 `pandoc-types` 構建一個輕量級轉換器，將 Typst 的 AST 映射到 DOCX 的 XML 結構 [21]。
* **公式處理**：利用 `latex2mathml` 或 `mathml2omml` crate 將數學公式轉換為 Word 可編輯的 OMML 格式 [22]。

## 3. 關鍵技術實作細節

### 3.1 跨語言橋接 (UniFFI Bridge)

這是連接 Swift 與 Rust 的關鍵。我們定義一個 `.udl` 檔案或使用 Rust 巨集來描述介面。

**Rust 介面定義 (`src/lib.rs`):**

```rust
#[derive(uniffi::Object)]
pub struct Engine {
    world: Arc<Mutex<SystemWorld>>, // Typst 的執行環境
}

#[uniffi::export]
impl Engine {
    #[uniffi::constructor]
    pub fn new() -> Arc<Self> {... }

    // 渲染預覽圖 (傳回 PNG 數據)
    pub fn render_preview(&self, source: String, ppi: f32) -> Vec<u8> {... }
    
    // 格式化引用
    pub fn format_citation(&self, items: Vec<String>, style: String) -> String {... }
}
```

**Swift 調用 (`ModelLayer.swift`):**

```swift
import RustCore // UniFFI 生成的模組

actor DocumentModel {
    private let engine: Engine
    
    init() {
        self.engine = Engine()
    }
    
    func updatePreview(content: String) async -> Image {
        let imageData = await engine.renderPreview(source: content, ppi: 300.0)
        return Image(uiImage: UIImage(data: imageData)!)
    }
}
```

### 3.2 編輯器 UI 與 Gutter 互動

為了讓使用者專注寫作，我們將 Agent 的干預最小化，移至 Gutter (行號區) [24]。

* **視圖選擇**：使用 `UITextView` (UIKit) 或 TextKit 2 進行高度客製化，而非標準的 `TextEditor` (SwiftUI 功能較受限)。
* **Gutter 實作**：在 `UITextView` 左側添加一個並排的 `UIView`。當 Agent 發現某段落有改進空間 (如語氣不正式、引用格式錯誤) 時，在該段落對應的 Gutter 位置顯示一個微小的指示燈 (Indicator)。使用者點擊指示燈，彈出浮動面板 (Floating Panel) 顯示 Agent 的建議與「一鍵修復」按鈕。

### 3.3 繁體中文優化策略

* **Tokenization**：在計算 Context Window 時，針對繁體中文 (CJK) 字符進行加權計算，避免因 Tokenizer 對中文支援不佳導致的長度誤判 [26]。
* **System Prompt 注入**：

    ```text
    "你是一個台灣學術寫作專家。請使用繁體中文（台灣）回應。
    術語對照表：
    Software -> 軟體
    Information -> 資訊
    Internet -> 網際網路
    Quality -> 品質 (非質量)
    請確保語氣客觀、嚴謹，避免過度口語化。"
    ```

    這些指令應硬編碼在 `LanguageModelSession` 的初始化配置中 [27]。

## 4. 數據流與儲存 (Data Flow & Persistence)

* **專案結構 (SwiftData)**：
  * `Project`: 包含標題、創建日期、關聯的書目 ID 列表。
  * `Document`: 實際的 `.typ` 原始碼，儲存為純文字。
  * `Bibliography`: 儲存 BibTeX/CSL-JSON 原始數據。
* **同步機制**：所有的寫入操作先存入本地 SQLite (SwiftData)。Rust 引擎每次編譯時，從 Swift 獲取最新的文字快照 (Snapshot)。
* **PDF 產物**：暫存在 `NSTemporaryDirectory`，不進入永久儲存，以節省空間。

## 5. 實作路徑建議 (Implementation Roadmap)

* **階段一：Rust 核心建置**
  * 搭建 UniFFI 環境。
  * 實作 Typst 的 `compile` 接口。
  * 驗證 iOS 上的 Hello World PDF 生成。
* **階段二：編輯器與 AI 串接**
  * 實作 TextKit 2 編輯器。
  * 整合 Apple Foundation Models，建立基本的 Rewrite/Summarize 功能。
  * 完成 Gutter UI 互動原型。
* **階段三：書目與格式系統**
  * 整合 Hayagriva 與 Zotero API。
  * 實作自定義 CSL 樣式支援。
  * 開發 Typst -> DOCX 的轉換管道。
* **階段四：繁體中文與體驗優化**
  * 微調 System Prompt。
  * 嵌入 Noto Sans TC 字體。
  * 進行學術論文的壓力測試 (長文檔效能優化)。

這套架構將 Rust 的效能與 Swift 的體驗完美結合，並利用 Apple Intelligence 實現了真正的本地化智慧輔助，是打造下一代學術編輯器的最佳技術路徑。
