//
//  NewContentView.swift
//  OVEREND
//
//  新版主內容視圖 - 整合三視圖系統
//

import SwiftUI
import CoreData
import UniformTypeIdentifiers

/// 新版主內容視圖
struct NewContentView: View {
    @Environment(\.managedObjectContext) private var viewContext
    
    @StateObject private var theme = AppTheme()
    @StateObject private var viewState = MainViewState()
    @StateObject private var libraryVM: LibraryViewModel
    
    @State private var showNewLibrarySheet = false
    @State private var showNewDocumentSheet = false
    @State private var showImportOptions = false
    @State private var importMessage: String?
    @State private var showImportAlert = false

    // AI 書目提取相關狀態
    @State private var isExtractingMetadata = false
    @State private var extractedMetadata: PDFMetadata?
    @State private var currentPDFURL: URL?
    @State private var showAIPreview = false
    
    init() {
        let context = PersistenceController.shared.container.viewContext
        _libraryVM = StateObject(wrappedValue: LibraryViewModel(context: context))
    }
    
    var body: some View {
        HStack(spacing: 0) {
            // 側邊欄 - 使用 Liquid Glass 效果
            NewSidebarView(libraryVM: libraryVM)
                .environmentObject(theme)
                .environmentObject(viewState)
                .frame(width: 220)

            // 主內容區域
            VStack(spacing: 0) {
                // 動態工具列
                DynamicToolbar(
                    searchText: $viewState.searchText,
                    onNewItem: handleNewItem
                )
                .environmentObject(theme)
                .environmentObject(viewState)

                // 視圖切換
                ZStack {
                    switch viewState.mode {
                    case .library:
                        // 文獻管理視圖
                        if let library = viewState.selectedLibrary ?? libraryVM.libraries.first {
                            ModernEntryListView(library: library)
                                .environmentObject(theme)
                                .environmentObject(viewState)
                        } else {
                            emptyLibraryState
                        }

                    case .editorList:
                        // 文稿列表視圖
                        EditorListView()
                            .environmentObject(theme)
                            .environmentObject(viewState)

                    case .editorFull(let document):
                        // 專業編輯器視圖
                        ProfessionalEditorView(document: document)
                            .environmentObject(theme)
                            .environmentObject(viewState)
                    
                    case .aiCenter:
                        // AI 智慧中心視圖
                        AICenterView()
                            .environmentObject(theme)
                            .environmentObject(viewState)
                    }
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
            }
            .background(theme.background)
        }
        .environmentObject(theme)
        .environmentObject(viewState)
        .withToast()
        .onAppear {
            if viewState.selectedLibrary == nil && !libraryVM.libraries.isEmpty {
                viewState.selectedLibrary = libraryVM.libraries.first
            }
        }
        .sheet(isPresented: $showImportOptions) {
            ImportOptionsSheet(
                onImportBibTeX: importBibTeX,
                onImportPDF: importPDF
            )
            .environmentObject(theme)
        }
        .sheet(isPresented: $showAIPreview) {
            if let metadata = extractedMetadata, let pdfURL = currentPDFURL {
                AIMetadataPreviewSheet(
                    metadata: metadata,
                    pdfURL: pdfURL,
                    onConfirm: { confirmedMetadata in
                        saveAIExtractedEntry(metadata: confirmedMetadata, pdfURL: pdfURL)
                    },
                    onRetry: {
                        retryMetadataExtraction(pdfURL: pdfURL)
                    }
                )
                .environmentObject(theme)
            }
        }
        .alert("匯入結果", isPresented: $showImportAlert, presenting: importMessage) { _ in
            Button("確定", role: .cancel) {}
        } message: { message in
            Text(message)
        }
        // 拖曳 PDF 匯入
        .onDrop(of: [.pdf, .fileURL], isTargeted: nil) { providers in
            handleDrop(providers: providers)
            return true
        }
        // AI 處理中的遮罩層
        .overlay {
            if isExtractingMetadata {
                ZStack {
                    Color.black.opacity(0.3)
                        .ignoresSafeArea()

                    VStack(spacing: DesignTokens.Spacing.lg) {
                        SpinnerLoadingIndicator(size: 48, lineWidth: 4)
                            .environmentObject(theme)

                        VStack(spacing: DesignTokens.Spacing.xs) {
                            Text("正在分析 PDF...")
                                .font(.system(size: DesignTokens.Typography.title2, weight: .bold))
                                .foregroundColor(.white)

                            Text("AI 正在提取書目信息")
                                .font(.system(size: DesignTokens.Typography.body))
                                .foregroundColor(.white.opacity(0.8))
                        }
                    }
                    .padding(DesignTokens.Spacing.xxl)
                    .background(
                        RoundedRectangle(cornerRadius: DesignTokens.CornerRadius.large)
                            .fill(.ultraThinMaterial)
                    )
                }
                .transition(.opacity)
                .animation(AnimationSystem.Easing.spring, value: isExtractingMetadata)
            }
        }
    }
    
    // MARK: - 拖曳 PDF 匯入
    
    private func handleDrop(providers: [NSItemProvider]) -> Bool {
        guard let library = viewState.selectedLibrary ?? libraryVM.libraries.first else {
            ToastManager.shared.showError("請先選擇文獻庫")
            return false
        }
        
        var importedCount = 0
        let group = DispatchGroup()
        
        for provider in providers {
            if provider.canLoadObject(ofClass: URL.self) {
                group.enter()
                _ = provider.loadObject(ofClass: URL.self) { url, error in
                    defer { group.leave() }
                    guard let url = url, url.pathExtension.lowercased() == "pdf" else { return }
                    
                    DispatchQueue.main.async {
                        self.importDroppedPDF(url: url, library: library)
                        importedCount += 1
                    }
                }
            }
        }
        
        group.notify(queue: .main) {
            if importedCount > 0 {
                ToastManager.shared.showSuccess("已匯入 \(importedCount) 個 PDF")
            }
        }
        
        return true
    }
    
    private func importDroppedPDF(url: URL, library: Library) {
        let entry = Entry(context: viewContext)
        entry.id = UUID()
        entry.entryType = "misc"
        let title = url.deletingPathExtension().lastPathComponent
            .replacingOccurrences(of: "_", with: " ")
            .replacingOccurrences(of: "-", with: " ")
        entry.citationKey = generateCitationKey(from: url)
        entry.fields = ["title": title]
        entry.bibtexRaw = "@misc{\(entry.citationKey),\n  title = {\(title)}\n}"
        entry.createdAt = Date()
        entry.updatedAt = Date()
        entry.library = library
        
        do {
            try PDFService.addPDFAttachment(from: url, to: entry, context: viewContext)
        } catch {
            print("附加 PDF 失敗：\(error)")
        }
    }
    
    // MARK: - 空狀態
    
    private var emptyLibraryState: some View {
        VStack(spacing: 24) {
            ZStack {
                Circle()
                    .fill(theme.accentLight)
                    .frame(width: 100, height: 100)
                
                Image(systemName: "books.vertical")
                    .font(.system(size: 40))
                    .foregroundColor(theme.accent)
            }
            
            VStack(spacing: 8) {
                Text("尚無文獻庫")
                    .font(.system(size: 20, weight: .bold))
                    .foregroundColor(theme.textPrimary)
                
                Text("建立您的第一個文獻庫開始使用")
                    .font(.system(size: 14))
                    .foregroundColor(theme.textMuted)
            }
            
            PrimaryButton("建立文獻庫", icon: "plus") {
                showNewLibrarySheet = true
            }
            .environmentObject(theme)
        }
    }
    
    // MARK: - 方法
    
    private func handleNewItem() {
        switch viewState.mode {
        case .library:
            // 顯示匯入選項
            showImportOptions = true
        case .editorList, .editorFull:
            // 新建文稿
            showNewDocumentSheet = true
        case .aiCenter:
            // AI 中心暫不支持新建
            break
        }
    }
    
    private func importBibTeX() {
        guard let library = viewState.selectedLibrary ?? libraryVM.libraries.first else { return }
        
        let panel = NSOpenPanel()
        panel.title = "匯入 BibTeX 檔案"
        panel.message = "選擇 .bib 檔案匯入書目資料"
        panel.allowedContentTypes = [.text, UTType(filenameExtension: "bib")!]
        panel.allowsMultipleSelection = false
        panel.canChooseDirectories = false
        panel.prompt = "匯入"
        
        panel.begin { response in
            if response == .OK, let url = panel.url {
                do {
                    let entries = try BibTeXParser.parseFile(at: url)
                    let count = try BibTeXParser.importEntries(entries, into: library, context: viewContext)
                    importMessage = "成功匯入 \(count) 筆書目"
                    showImportAlert = true
                } catch {
                    importMessage = "匯入失敗：\(error.localizedDescription)"
                    showImportAlert = true
                }
            }
        }
    }
    
    private func importPDF() {
        guard let library = viewState.selectedLibrary ?? libraryVM.libraries.first else { return }

        let panel = NSOpenPanel()
        panel.title = "匯入 PDF 檔案"
        panel.message = "選擇 PDF 檔案，AI 將自動提取書目信息"
        panel.allowedContentTypes = [.pdf]
        panel.allowsMultipleSelection = true  // 啟用批次選擇
        panel.canChooseDirectories = false
        panel.prompt = "匯入"

        panel.begin { response in
            if response == .OK {
                let urls = panel.urls
                if urls.count == 1 {
                    // 單個文件：使用 AI 預覽流程
                    self.extractAndShowMetadata(from: urls[0])
                } else if urls.count > 1 {
                    // 多個文件：批次自動匯入
                    self.batchImportPDFs(urls: urls, into: library)
                }
            }
        }
    }
    
    /// 批次匯入 PDF 文件
    private func batchImportPDFs(urls: [URL], into library: Library) {
        let totalCount = urls.count
        var successCount = 0
        var failedCount = 0
        
        // 顯示進度提示
        ToastManager.shared.showInfo("正在處理 \(totalCount) 個 PDF 文件...")
        
        Task {
            for (index, url) in urls.enumerated() {
                do {
                    // 提取元數據
                    let metadata = await PDFMetadataExtractor.extractMetadata(from: url)
                    
                    // 保存到資料庫
                    await MainActor.run {
                        do {
                            try self.savePDFEntry(metadata: metadata, pdfURL: url, library: library)
                            successCount += 1
                        } catch {
                            print("保存失敗：\(url.lastPathComponent) - \(error.localizedDescription)")
                            failedCount += 1
                        }
                    }
                } catch {
                    print("處理失敗：\(url.lastPathComponent) - \(error.localizedDescription)")
                    failedCount += 1
                }
                
                // 每處理 5 個文件更新一次進度
                if (index + 1) % 5 == 0 {
                    await MainActor.run {
                        ToastManager.shared.showInfo("已處理 \(index + 1)/\(totalCount)...")
                    }
                }
            }
            
            // 顯示最終結果
            await MainActor.run {
                if failedCount == 0 {
                    ToastManager.shared.showSuccess("成功匯入 \(successCount) 個 PDF 文件")
                } else {
                    ToastManager.shared.showWarning("成功 \(successCount) 個，失敗 \(failedCount) 個")
                }
            }
        }
    }

    // MARK: - AI 元數據提取方法

    /// 提取並顯示元數據
    private func extractAndShowMetadata(from url: URL) {
        currentPDFURL = url
        isExtractingMetadata = true

        Task {
            do {
                // AI 提取元數據
                let metadata = await PDFMetadataExtractor.extractMetadata(from: url)

                await MainActor.run {
                    extractedMetadata = metadata
                    isExtractingMetadata = false
                    showAIPreview = true
                }
            } catch {
                await MainActor.run {
                    isExtractingMetadata = false
                    ToastManager.shared.showError("PDF 分析失敗：\(error.localizedDescription)")
                }
            }
        }
    }

    /// 重試元數據提取
    private func retryMetadataExtraction(pdfURL: URL) {
        extractAndShowMetadata(from: pdfURL)
    }

    /// 保存 AI 提取的 Entry
    private func saveAIExtractedEntry(metadata: PDFMetadata, pdfURL: URL) {
        guard let library = viewState.selectedLibrary ?? libraryVM.libraries.first else {
            ToastManager.shared.showError("請先選擇文獻庫")
            return
        }

        do {
            // 建立新的 Entry
            let entry = Entry(context: viewContext)
            entry.id = UUID()
            entry.entryType = metadata.entryType
            let citationKey = generateCitationKey(from: metadata)
            entry.citationKey = citationKey
            entry.createdAt = Date()
            entry.updatedAt = Date()
            entry.library = library

            // 設置欄位
            var fields: [String: String] = ["title": metadata.title]

            if !metadata.authors.isEmpty {
                fields["author"] = metadata.authors.joined(separator: " and ")
            }

            if let year = metadata.year {
                fields["year"] = year
            }

            if let doi = metadata.doi {
                fields["doi"] = doi
            }

            if let journal = metadata.journal {
                fields["journal"] = journal
            }

            if let abstract = metadata.abstract {
                fields["abstract"] = abstract
            }

            entry.fields = fields

            // 生成 BibTeX
            entry.bibtexRaw = PDFMetadataExtractor.generateBibTeX(from: metadata, citationKey: citationKey)

            // 附加 PDF
            try PDFService.addPDFAttachment(from: pdfURL, to: entry, context: viewContext)

            // 顯示成功提示
            let confidenceText = metadata.confidence == .high ? " (高可信度)" : ""
            ToastManager.shared.showSuccess("成功匯入 PDF\(confidenceText)")

        } catch {
            ToastManager.shared.showError("保存失敗：\(error.localizedDescription)")
        }
    }

    /// 從元數據生成引用鍵
    private func generateCitationKey(from metadata: PDFMetadata) -> String {
        var key = ""

        // 使用第一作者的姓氏
        if let firstAuthor = metadata.authors.first {
            let lastName = firstAuthor.components(separatedBy: " ").last ?? firstAuthor
            key = lastName.lowercased()
        }

        // 添加年份
        if let year = metadata.year {
            key += year
        }

        // 添加標題的前幾個單詞
        let titleWords = metadata.title
            .components(separatedBy: .whitespaces)
            .prefix(2)
            .map { $0.lowercased() }
            .joined()

        key += titleWords

        // 清理非字母數字字符
        key = key.components(separatedBy: CharacterSet.alphanumerics.inverted).joined()

        // 如果 key 太短，添加時間戳
        if key.count < 5 {
            key += "\(Int(Date().timeIntervalSince1970) % 10000)"
        }

        return key.isEmpty ? "entry\(Int(Date().timeIntervalSince1970))" : key
    }
    
    private func generateCitationKey(from url: URL) -> String {
        let name = url.deletingPathExtension().lastPathComponent
        let sanitized = name.components(separatedBy: CharacterSet.alphanumerics.inverted).joined()
        let timestamp = Int(Date().timeIntervalSince1970) % 10000
        return "\(sanitized.prefix(20))_\(timestamp)"
    }
}

// MARK: - 匯入選項 Sheet

struct ImportOptionsSheet: View {
    @EnvironmentObject var theme: AppTheme
    @Environment(\.dismiss) private var dismiss
    
    let onImportBibTeX: () -> Void
    let onImportPDF: () -> Void
    
    var body: some View {
        VStack(spacing: 24) {
            Text("匯入文獻")
                .font(.system(size: 18, weight: .bold))
            
            HStack(spacing: 20) {
                // BibTeX 匯入
                ImportOptionCard(
                    icon: "doc.text",
                    title: "BibTeX",
                    description: "匯入 .bib 書目檔案"
                ) {
                    dismiss()
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                        onImportBibTeX()
                    }
                }
                
                // PDF 匯入
                ImportOptionCard(
                    icon: "doc.richtext",
                    title: "PDF",
                    description: "匯入 PDF 並建立書目"
                ) {
                    dismiss()
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                        onImportPDF()
                    }
                }
            }
            
            SecondaryButton("取消") {
                dismiss()
            }
            .environmentObject(theme)
            .keyboardShortcut(.escape)
        }
        .padding(32)
    }
}

struct ImportOptionCard: View {
    @EnvironmentObject var theme: AppTheme
    
    let icon: String
    let title: String
    let description: String
    let action: () -> Void
    
    @State private var isHovered = false
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 12) {
                ZStack {
                    RoundedRectangle(cornerRadius: 12)
                        .fill(isHovered ? theme.accent : theme.accentLight)
                        .frame(width: 56, height: 56)
                    
                    Image(systemName: icon)
                        .font(.system(size: 24))
                        .foregroundColor(isHovered ? .white : theme.accent)
                }
                
                Text(title)
                    .font(.system(size: 16, weight: .bold))
                    .foregroundColor(theme.textPrimary)
                
                Text(description)
                    .font(.system(size: 15))
                    .foregroundColor(theme.textMuted)
                    .multilineTextAlignment(.center)
            }
            .padding(20)
            .frame(width: 160)
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(theme.card)
                    .overlay(
                        RoundedRectangle(cornerRadius: 12)
                            .stroke(isHovered ? theme.accent : theme.border, lineWidth: 1)
                    )
            )
        }
        .buttonStyle(.plain)
        .onHover { hovering in
            withAnimation(AnimationSystem.Easing.quick) {
                isHovered = hovering
            }
        }
    }
}

#Preview {
    NewContentView()
        .environment(\.managedObjectContext, PersistenceController.preview.container.viewContext)
        .frame(width: 1200, height: 800)
}


    /// 保存 PDF Entry（用於批次匯入）
    private func savePDFEntry(metadata: PDFMetadata, pdfURL: URL, library: Library) throws {
        let entry = Entry(context: viewContext)
        entry.id = UUID()
        entry.entryType = metadata.entryType
        let citationKey = generateCitationKey(from: metadata)
        entry.citationKey = citationKey
        entry.createdAt = Date()
        entry.updatedAt = Date()
        entry.library = library
        
        var fields: [String: String] = ["title": metadata.title]
        if !metadata.authors.isEmpty { fields["author"] = metadata.authors.joined(separator: " and ") }
        if let year = metadata.year { fields["year"] = year }
        if let doi = metadata.doi { fields["doi"] = doi }
        if let journal = metadata.journal { fields["journal"] = journal }
        if let abstract = metadata.abstract { fields["abstract"] = abstract }
        
        entry.fields = fields
        entry.bibtexRaw = PDFMetadataExtractor.generateBibTeX(from: metadata, citationKey: citationKey)
        try PDFService.addPDFAttachment(from: pdfURL, to: entry, context: viewContext)
    }
}
