//
//  BibTeXGenerator.swift
//  OVEREND
//
//  BibTeX 生成器 - 將書目導出為 .bib 文件
//

import Foundation
import CoreData

class BibTeXGenerator {
    enum GeneratorError: Error {
        case emptyEntries
        case invalidEntry
        case fileWriteFailed
    }

    /// 生成單個書目的 BibTeX 字符串
    /// - Parameter entry: Core Data Entry 實體
    /// - Returns: BibTeX 格式字符串
    static func generate(from entry: Entry) -> String {
        var bib = "@\(entry.entryType){\(entry.citationKey),\n"

        // 按字母順序排列字段
        let sortedFields = entry.fields.sorted { $0.key < $1.key }

        for (key, value) in sortedFields {
            bib += "  \(key) = {\(escapeValue(value))},\n"
        }

        bib += "}\n"
        return bib
    }

    /// 批量生成多個書目
    /// - Parameter entries: 書目數組
    /// - Returns: 完整的 BibTeX 文件內容
    static func generate(from entries: [Entry]) -> String {
        guard !entries.isEmpty else {
            return ""
        }

        var bibContent = ""

        // 添加文件頭註釋
        bibContent += "% Generated by OVEREND - \(Date().formatted())\n"
        bibContent += "% \(entries.count) entries\n\n"

        // 生成每個書目
        for entry in entries {
            bibContent += generate(from: entry)
            bibContent += "\n" // 書目之間空一行
        }

        return bibContent
    }

    /// 導出整個庫
    /// - Parameter library: 文獻庫
    /// - Returns: BibTeX 文件內容
    static func exportLibrary(_ library: Library, in context: NSManagedObjectContext) -> String {
        let entries = Entry.fetchAll(in: library, context: context)
        return generate(from: entries)
    }

    /// 導出到文件
    /// - Parameters:
    ///   - entries: 要導出的書目
    ///   - fileURL: 目標文件路徑
    /// - Throws: 文件寫入錯誤
    static func export(_ entries: [Entry], to fileURL: URL) throws {
        guard !entries.isEmpty else {
            throw GeneratorError.emptyEntries
        }

        let bibContent = generate(from: entries)

        try bibContent.write(to: fileURL, atomically: true, encoding: .utf8)
    }

    /// 導出整個庫到文件
    /// - Parameters:
    ///   - library: 文獻庫
    ///   - fileURL: 目標文件路徑
    ///   - context: Core Data 上下文
    /// - Throws: 文件寫入錯誤
    static func exportLibrary(
        _ library: Library,
        to fileURL: URL,
        in context: NSManagedObjectContext
    ) throws {
        let entries = Entry.fetchAll(in: library, context: context)
        try export(entries, to: fileURL)
    }

    // MARK: - 輔助方法

    /// 轉義 BibTeX 特殊字符
    /// - Parameter value: 原始值
    /// - Returns: 轉義後的值
    private static func escapeValue(_ value: String) -> String {
        var escaped = value

        // 保留 LaTeX 命令，但轉義特殊字符
        let replacements: [(String, String)] = [
            ("{", "\\{"),
            ("}", "\\}"),
            ("%", "\\%"),
            ("&", "\\&"),
            ("$", "\\$"),
            ("_", "\\_"),
            ("#", "\\#")
        ]

        // 注意：如果值已經包含 LaTeX 命令，不要重複轉義
        // 這裡簡化處理，實際應用可能需要更智能的判斷
        if !escaped.contains("\\") {
            for (char, replacement) in replacements {
                escaped = escaped.replacingOccurrences(of: char, with: replacement)
            }
        }

        return escaped
    }

    /// 格式化作者列表
    /// - Parameter authors: 作者字符串（可能包含多個作者）
    /// - Returns: 格式化的作者字符串
    static func formatAuthors(_ authors: String) -> String {
        // 支持 "and" 分隔的多作者
        let authorList = authors.components(separatedBy: " and ")

        return authorList.joined(separator: " and ")
    }

    /// 驗證生成的 BibTeX
    /// - Parameter bibContent: BibTeX 內容
    /// - Returns: 是否有效
    static func validate(_ bibContent: String) -> Bool {
        // 基本驗證：檢查是否包含 @ 符號和大括號
        return bibContent.contains("@") && bibContent.contains("{") && bibContent.contains("}")
    }
}

// MARK: - 擴展：引用鍵生成

extension BibTeXGenerator {
    /// 生成引用鍵
    /// - Parameters:
    ///   - author: 作者
    ///   - year: 年份
    ///   - title: 標題（可選）
    /// - Returns: 引用鍵
    static func generateCitationKey(author: String, year: String, title: String? = nil) -> String {
        // 提取第一作者的姓氏
        let firstAuthor = author.components(separatedBy: " and ").first ?? "unknown"
        let lastName = firstAuthor.components(separatedBy: " ").last ?? "unknown"

        // 清理姓氏（移除特殊字符）
        let cleanLastName = lastName.lowercased()
            .replacingOccurrences(of: " ", with: "")
            .replacingOccurrences(of: "[^a-z]", with: "", options: .regularExpression)

        var citationKey = "\(cleanLastName)\(year)"

        // 如果有標題，添加第一個單詞（可選）
        if let title = title,
           let firstWord = title.components(separatedBy: " ").first {
            let cleanWord = firstWord.lowercased()
                .replacingOccurrences(of: "[^a-z]", with: "", options: .regularExpression)

            if cleanWord.count >= 3 {
                citationKey += "-\(cleanWord)"
            }
        }

        return citationKey
    }

    /// 確保引用鍵唯一性
    /// - Parameters:
    ///   - baseKey: 基礎引用鍵
    ///   - context: Core Data 上下文
    /// - Returns: 唯一的引用鍵
    static func ensureUniqueCitationKey(_ baseKey: String, in context: NSManagedObjectContext) -> String {
        var uniqueKey = baseKey
        var counter = 1

        while Entry.find(byCitationKey: uniqueKey, in: context) != nil {
            uniqueKey = "\(baseKey)-\(counter)"
            counter += 1
        }

        return uniqueKey
    }
}
